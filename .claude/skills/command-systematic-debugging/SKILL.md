---
name: command-systematic-debugging
description: "4단계 근본 원인 분석(증상 수집, 가설 수립, 격리 검증, 수정 확인) 방법론으로 버그를 체계적으로 진단하고 해결한다. 심층 방어 디버깅, 조건 기반 대기 패턴, 에러 처리 일관성 가이드를 포함. Use when 버그 디버깅, 에러 추적, 근본 원인 분석, 에러 핸들링 패턴 수립이 필요할 때. 키워드: 디버깅, debugging, 버그, bug, 에러, error, root-cause, 에러 핸들링, exception handling, graceful degradation."
---

# Systematic Debugging

체계적인 방법론으로 버그의 근본 원인을 찾아 해결하는 가이드. 감으로 코드를 바꾸지 말고, 증거 기반으로 원인을 격리하여 수정한다.

## 역할 분리

| 스킬 | 역할 | 시점 |
|------|------|------|
| **command-systematic-debugging** | 문제 발생 시 근본 원인 분석 및 해결 전략 | 버그/에러 발생 시 (사중) |
| command-verification-before-completion | 완료 선언 전 검증 증거 확보 | 작업 완료 직전 (사후) |

## 4단계 근본 원인 분석 (RCA)

모든 디버깅은 이 4단계를 순서대로 따른다. 단계를 건너뛰지 않는다.

### Stage 1: 증상 수집 (Symptom Collection)

문제를 정확히 정의하고 재현 가능한 증거를 확보한다.

**필수 수집 항목:**

| 항목 | 수집 방법 | 예시 |
|------|----------|------|
| 에러 메시지 전문 | 로그, 콘솔, stderr 캡처 | `TypeError: Cannot read property 'x' of undefined` |
| 스택 트레이스 | 전체 트레이스 보존 (잘림 없이) | 호출 경로 전체 |
| 재현 조건 | 입력값, 환경, 타이밍 | "POST /api/users with empty body" |
| 발생 빈도 | 항상/간헐적/특정 조건 | "2번 중 1번 실패" |
| 최근 변경사항 | git log, 배포 이력 | "3시간 전 auth 모듈 변경" |

**재현 스크립트 작성 원칙:**

```
1. 최소 재현 코드(MRE)를 먼저 작성
2. 외부 의존성을 최소화
3. 한 번 실행으로 증상이 나타나는 형태로 축소
4. 재현 성공 후 다음 단계로 이동
```

**재현 불가 시 대응:**

- 로깅 강화: 의심 경로에 상세 로그 추가
- 조건 분기 수집: 어떤 조건에서 발생/미발생인지 경계값 좁히기
- 스냅샷 비교: 정상 실행 vs 비정상 실행의 상태 차이 기록

### Stage 2: 가설 수립 (Hypothesis Formation)

수집된 증상을 기반으로 가능한 원인 가설을 도출한다.

**가설 수립 절차:**

```
1. 증상에서 직접 유추 가능한 원인 목록 작성 (보통 3-5개)
2. 각 가설에 우선순위 부여 (증거 기반)
3. 가장 가능성 높은 가설부터 검증 계획 수립
```

**가설 우선순위 기준:**

| 우선순위 | 기준 | 근거 |
|---------|------|------|
| 1순위 | 최근 변경된 코드 | 변경이 없으면 버그도 없다 |
| 2순위 | 에러 메시지가 직접 가리키는 위치 | 가장 직접적 증거 |
| 3순위 | 유사 패턴의 과거 버그 | 같은 실수는 반복된다 |
| 4순위 | 외부 의존성 변경 | 버전 업그레이드, API 변경 |
| 5순위 | 환경/설정 차이 | 로컬 vs 스테이징 vs 프로덕션 |

**가설 기록 양식:**

```markdown
| # | 가설 | 예상 증거 | 검증 방법 | 결과 |
|---|------|----------|----------|------|
| 1 | auth 모듈의 null 체크 누락 | token이 null일 때 crash | null token으로 호출 | (검증 후 기록) |
| 2 | DB 연결 타임아웃 | 간헐적 ConnectionError | 연결 풀 상태 확인 | (검증 후 기록) |
```

### Stage 3: 격리 검증 (Isolation & Verification)

가설을 하나씩 검증하여 근본 원인을 격리한다.

**격리 검증 전략:**

**이분 탐색 (Binary Search):**
```
1. 문제 범위의 중간 지점에 검증 포인트 삽입
2. 정상/비정상 경계를 절반씩 좁히기
3. git bisect 활용: 정상 커밋 ~ 비정상 커밋 사이 이분 탐색
```

**변수 고정 (Variable Isolation):**
```
1. 한 번에 하나의 변수만 변경
2. 나머지 조건은 고정
3. 변수 변경이 증상에 영향을 주는지 확인
4. 영향을 주는 변수 = 원인 후보
```

**최소 차이 비교 (Minimal Diff):**
```
1. 정상 동작하는 상태와 비정상 상태의 차이를 최소화
2. 차이가 1개로 좁혀질 때까지 반복
3. 최종 차이 = 근본 원인
```

**검증 체크리스트:**

- [ ] 가설의 예상 증거가 실제로 관찰되는가?
- [ ] 원인을 제거하면 증상이 사라지는가?
- [ ] 원인을 다시 추가하면 증상이 재현되는가?
- [ ] 다른 가설로는 설명할 수 없는가?

### Stage 4: 수정 확인 (Fix Verification)

근본 원인을 수정하고, 수정이 올바른지 다층 검증한다.

**수정 확인 절차:**

```
1. 근본 원인에 대한 수정 코드 작성
2. 재현 스크립트로 증상 해소 확인 (Red -> Green)
3. 기존 테스트 스위트 전체 실행 (회귀 없음 확인)
4. 엣지 케이스 추가 테스트 (경계값, null, 빈 값, 동시성)
5. 수정 커밋에 근본 원인 설명 포함
```

**수정 커밋 메시지 구조:**

```
fix: [증상 요약]

Root cause: [근본 원인 1-2줄 설명]
Verification: [검증 방법과 결과]
```

## 심층 방어 디버깅 전략 (Defense-in-Depth)

복잡한 버그나 다층 시스템에서 한 가지 방법으로 원인을 찾지 못할 때 적용한다.

### 다층 관찰 기법

| 계층 | 관찰 도구 | 확인 대상 |
|------|----------|----------|
| 코드 | 브레이크포인트, print/log | 변수 상태, 실행 경로 |
| 런타임 | 프로파일러, 메모리 분석기 | 성능 병목, 메모리 릭 |
| 시스템 | strace, netstat, top | 시스템콜, 네트워크, 리소스 |
| 인프라 | 클라우드 메트릭, APM | 레이턴시, 에러율, 처리량 |

### 타임라인 분석

```
1. 정상 동작 시점 확인 (마지막 성공)
2. 최초 실패 시점 확인
3. 그 사이 변경사항 전부 나열 (코드, 설정, 인프라, 외부 서비스)
4. 변경사항-증상 상관관계 매핑
```

### 동시성 버그 진단

동시성 버그(레이스 컨디션, 데드락, 라이브락)는 특별한 접근이 필요하다:

```
1. 타이밍 의존성 확인: sleep/delay 삽입으로 발생 빈도 변화 관찰
2. 직렬화 테스트: 병렬 실행을 직렬로 바꿔서 증상 사라지는지 확인
3. 로그 순서 분석: 이벤트 타임스탬프로 실행 순서 재구성
4. 스레드 덤프: 데드락 시 스레드 상태 전체 캡처
```

## 조건 기반 대기 패턴 (Conditional Wait)

비동기 작업, 외부 서비스 호출, 이벤트 기반 시스템에서 타이밍 문제를 방지한다.

### 안티패턴: 고정 대기

```python
# BAD: 고정 시간 대기
time.sleep(5)
assert resource.is_ready()
```

### 올바른 패턴: 조건 기반 대기

```python
# GOOD: 조건이 충족될 때까지 폴링
def wait_for(condition, timeout=30, interval=0.5):
    deadline = time.time() + timeout
    while time.time() < deadline:
        if condition():
            return True
        time.sleep(interval)
    raise TimeoutError(f"Condition not met within {timeout}s")

wait_for(lambda: resource.is_ready())
```

### 대기 패턴 적용 기준

| 상황 | 패턴 | 타임아웃 기본값 |
|------|------|---------------|
| DB 마이그레이션 완료 대기 | 폴링 + 상태 체크 | 60s |
| API 서버 시작 대기 | 헬스체크 엔드포인트 폴링 | 30s |
| 파일 시스템 변경 감지 | inotify/watchdog 또는 폴링 | 10s |
| 메시지 큐 소비 대기 | 큐 길이 폴링 | 30s |
| CI/CD 파이프라인 완료 | 상태 API 폴링 | 300s |

**필수 원칙:**
- 모든 대기에 타임아웃을 반드시 설정
- 타임아웃 초과 시 명확한 에러 메시지 제공
- 폴링 간격은 대상 시스템 부하를 고려하여 설정

## 에러 처리 일관성 가이드

프로젝트 전체에서 일관된 에러 처리 패턴을 적용한다.

### 글로벌 에러 핸들링 전략

```
1. 최상위 에러 핸들러 설정 (unhandled exception/rejection 캐치)
2. 에러 분류 체계 정의 (아래 테이블 참조)
3. 각 분류별 처리 전략 통일
4. 에러 로깅 포맷 표준화
```

**에러 분류 체계:**

| 분류 | HTTP 코드 | 처리 전략 | 사용자 메시지 |
|------|----------|----------|-------------|
| 입력 검증 에러 | 400 | 즉시 반환, 필드별 상세 | "입력값을 확인해 주세요: {details}" |
| 인증 에러 | 401 | 세션 초기화, 재로그인 유도 | "로그인이 필요합니다" |
| 권한 에러 | 403 | 로깅, 접근 거부 표시 | "이 작업에 대한 권한이 없습니다" |
| 리소스 없음 | 404 | 폴백 UI 표시 | "요청한 항목을 찾을 수 없습니다" |
| 비즈니스 로직 에러 | 422 | 도메인별 처리 | 도메인 컨텍스트에 맞는 메시지 |
| 서버 내부 에러 | 500 | 재시도 후 에스컬레이션 | "일시적 오류가 발생했습니다. 잠시 후 다시 시도해 주세요" |
| 외부 서비스 에러 | 502/503 | 재시도 + 서킷 브레이커 | "서비스 연결 중 문제가 발생했습니다" |

### 사용자 친화적 에러 메시지 원칙

```
1. 기술 용어 대신 사용자 행동 중심 메시지
2. 무엇이 잘못되었는지 + 어떻게 해결하는지 안내
3. 민감 정보(스택 트레이스, 내부 경로) 절대 노출 금지
4. 에러 코드를 포함하여 지원팀 문의 시 추적 가능하게
```

**양호한 예시 vs 미흡한 예시:**

| 미흡 | 양호 |
|------|------|
| `NullPointerException at UserService:42` | "프로필을 불러올 수 없습니다. 잠시 후 다시 시도해 주세요. (ERR-1042)" |
| `ECONNREFUSED 127.0.0.1:5432` | "서비스 연결 중 문제가 발생했습니다. 잠시 후 다시 시도해 주세요. (ERR-2001)" |
| `500 Internal Server Error` | "요청을 처리하는 중 오류가 발생했습니다. 문제가 계속되면 고객센터에 문의해 주세요." |

### 재시도 패턴 (Retry Pattern)

**지수 백오프 + 지터:**

```python
import random

def retry_with_backoff(fn, max_retries=3, base_delay=1.0):
    for attempt in range(max_retries):
        try:
            return fn()
        except RetryableError as e:
            if attempt == max_retries - 1:
                raise
            delay = base_delay * (2 ** attempt) + random.uniform(0, 1)
            time.sleep(delay)
```

**재시도 판단 기준:**

| 재시도 대상 | 재시도 금지 |
|------------|-----------|
| 네트워크 타임아웃 (5xx, timeout) | 입력 검증 실패 (4xx) |
| 일시적 DB 연결 실패 | 인증/권한 에러 (401/403) |
| 외부 서비스 일시 장애 | 비즈니스 로직 에러 |
| 락 경합 (optimistic lock) | 리소스 없음 (404) |

### 그레이스풀 디그레이드 (Graceful Degradation)

시스템 일부가 실패해도 핵심 기능을 유지하는 전략:

```
1. 기능별 중요도 분류 (핵심 / 보조 / 장식)
2. 보조/장식 기능 실패 시: 로깅 후 기본값 표시, 핵심 기능 계속
3. 핵심 기능 실패 시: 사용자에게 명확한 에러 표시, 복구 방법 안내
4. 캐시 폴백: 외부 서비스 실패 시 캐시된 데이터로 제공 (stale 표시)
5. 기능 플래그: 문제 기능을 런타임에 비활성화 가능하도록 설계
```

**서킷 브레이커 패턴:**

```
상태: CLOSED (정상) -> OPEN (차단) -> HALF-OPEN (시험)

CLOSED: 요청을 정상 전달. 실패 카운트 추적
  -> 실패 임계치 초과 시 OPEN으로 전환

OPEN: 요청을 즉시 실패 처리 (외부 호출 안 함). 타이머 시작
  -> 타이머 만료 시 HALF-OPEN으로 전환

HALF-OPEN: 제한된 수의 요청만 전달하여 복구 확인
  -> 성공 시 CLOSED로 복귀
  -> 실패 시 OPEN으로 재전환
```

## 언어별 디버깅 도구 빠른 참조

| 언어 | 디버거 | 프로파일러 | 로깅 |
|------|--------|----------|------|
| Python | pdb, ipdb, debugpy | cProfile, py-spy | logging, structlog |
| JavaScript/TS | Chrome DevTools, node --inspect | --prof, clinic.js | console, pino, winston |
| Go | delve | pprof, trace | log/slog, zerolog |
| Rust | rust-gdb, rust-lldb | perf, flamegraph | tracing, env_logger |
| Java/Kotlin | JDB, IntelliJ debugger | JFR, async-profiler | SLF4J, Logback |

## 디버깅 세션 체크리스트

디버깅 작업 시작 시 이 체크리스트를 따른다:

- [ ] **Stage 1**: 에러 메시지와 스택 트레이스를 전문 수집했는가?
- [ ] **Stage 1**: 최소 재현 코드(MRE)를 작성했는가?
- [ ] **Stage 2**: 가능한 원인 가설을 3개 이상 도출했는가?
- [ ] **Stage 2**: 가설에 우선순위를 부여했는가?
- [ ] **Stage 3**: 한 번에 하나의 변수만 변경하며 검증했는가?
- [ ] **Stage 3**: 원인 제거 시 증상이 사라지는 것을 확인했는가?
- [ ] **Stage 4**: 수정 후 재현 스크립트로 해소를 확인했는가?
- [ ] **Stage 4**: 기존 테스트 스위트에서 회귀가 없는가?
- [ ] **Stage 4**: 엣지 케이스 테스트를 추가했는가?
